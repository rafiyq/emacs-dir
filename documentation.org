#+TITLE: Emacs Configuration File/init.el Documentation
#+PROPERTY: header-args :tangle yes

* Variable Definition
** init-file-loaded-p
Non-nil if the init-file has already been loaded.
This is important for Emacs 27 and above, since our early
init-file just loads the regular init-file, which would lead to
loading the init-file twice if it were not for this variable.
#+begin_src emacs-lisp
   (defvar init-file-loaded-p nil)
#+end_src
** minimum-emacs-version
Radian Emacs does not support any Emacs version below this.
#+begin_src emacs-lisp
  (defvar minimum-emacs-version "25.2")
#+end_src
** finalize-init-hook
Hook run unconditionally after init, even if it fails.
Unlike `after-init-hook', this hook is run every time the
init-file is loaded, not just once.
#+begin_src emacs-lisp
  (defvar finalize-init-hook nil)
#+end_src
* Macro Definition
** protect-macros
Eval BODY, protecting macros from incorrect expansion.
This macro should be used in the following situation:

Some form is being evaluated, and this form contains as a
sub-form some code that will not be evaluated immediately, but
will be evaluated later. The code uses a macro that is not
defined at the time the top-level form is evaluated, but will be
defined by time the sub-form's code is evaluated. This macro
handles its arguments in some way other than evaluating them
directly. And finally, one of the arguments of this macro could
be interpreted itself as a macro invocation, and expanding the
invocation would break the evaluation of the outer macro.

You might think this situation is such an edge case that it would
never happen, but you'd be wrong, unfortunately. In such a
situation, you must wrap at least the outer macro in this form,
but can wrap at any higher level up to the top-level form.
#+begin_src emacs-lisp
  (defmacro protect-macros (&rest body)
    (declare (indent 0))
    `(eval '(progn ,@body)))
#+end_src
** flet
Temporarily override function definitions using `cl-letf*'.
BINDINGS are composed of `defun'-ish forms. NAME is the function
to override. It has access to the original function as a
lexically bound variable by the same name, for use with
`funcall'. ARGLIST and BODY are as in `defun'.
\(fn ((defun NAME ARGLIST &rest BODY) ...) BODY...)
#+begin_src emacs-lisp
  (defmacro flet (bindings &rest body)
    (declare (indent defun))
    `(cl-letf* (,@(cl-mapcan
		   (lambda (binding)
		     (when (memq (car binding) '(defun lambda))
		       (setq binding (cdr binding)))
		     (cl-destructuring-bind (name arglist &rest body) binding
		       (list
			`(,name (symbol-function #',name))
			`((symbol-function #',name)
			  (lambda ,arglist
			    ,@body)))))
		   bindings))
       ,@body))

#+end_src
** defadvice
Define an advice called NAME and add it to a function.
ARGLIST is as in `defun'. WHERE is a keyword as passed to
`advice-add', and PLACE is the function to which to add the
advice, like in `advice-add'. PLACE should be sharp-quoted.
DOCSTRING and BODY are as in `defun'.
#+begin_src emacs-lisp
  (defmacro defadvice (name arglist where place docstring &rest body)
    (declare (indent 2)
	     (doc-string 5))
    (unless (stringp docstring)
      (error "Advice `%S' not documented'" name))
    (unless (and (listp place)
		 (= 2 (length place))
		 (eq (nth 0 place) 'function)
		 (symbolp (nth 1 place)))
      (error "Advice `%S' does not sharp-quote place `%S'" name place))
    `(progn
#+end_src
     ;; You'd think I would put an `eval-and-compile' around this. It
     ;; turns out that doing so breaks the ability of
     ;; `elisp-completion-at-point' to complete on function arguments
     ;; to the advice. I know, right? Apparently this is because the
     ;; code that gets the list of lexically bound symbols at point
     ;; tries to `macroexpand-all', and apparently macroexpanding
     ;; `eval-and-compile' goes ahead and evals the thing and returns
     ;; only the function symbol. No good. But the compiler does still
     ;; want to know the function is defined (this is a Gilardi
     ;; scenario), so we pacify it by `eval-when-compile'ing something
     ;; similar (see below).
#+begin_src emacs-lisp
       (defun ,name ,arglist
	 ,(let ((article (if (string-match-p "^:[aeiou]" (symbol-name where))
			     "an"
			   "a")))
	    (format "%s\n\nThis is %s `%S' advice for `%S'."
		    docstring article where
		    (if (and (listp place)
			     (memq (car place) ''function))
			(cadr place)
		      place)))
	 ,@body)
       (eval-when-compile
	 (declare-function ,name nil))
       (advice-add ,place ',where #',name)
       ',name))

#+end_src
** defhook
Define a function called NAME and add it to a hook.
ARGLIST is as in `defun'. HOOKS is a list of hooks to which to
add the function, or just a single hook. DOCSTRING and BODY are
as in `defun'.
#+begin_src emacs-lisp
  (defmacro defhook (name arglist hooks docstring &rest body)
    (declare (indent 2)
	     (doc-string 4))
    (unless (listp hooks)
      (setq hooks (list hooks)))
    (dolist (hook hooks)
      (unless (string-match-p "-\\(hook\\|functions\\)$" (symbol-name hook))
	(error "Symbol `%S' is not a hook" hook)))
    (unless (stringp docstring)
      (error "No docstring provided for `defhook'"))
    (let ((hooks-str (format "`%S'" (car hooks))))
      (dolist (hook (cdr hooks))
	(setq hooks-str (format "%s\nand `%S'" hooks-str hook)))
      `(progn
	 (defun ,name ,arglist
	   ,(format "%s\n\nThis function is for use in %s."
		    docstring hooks-str)
	   ,@body)
	 (dolist (hook ',hooks)
	   (add-hook hook ',name)))))
#+end_src
** operating-system-p
Return non-nil if OS corresponds to the current operating system.
Allowable values for OS (not quoted) are `macOS', `osx',
`windows', `linux', `unix'.
#+begin_src emacs-lisp
  (defmacro radian-operating-system-p (os)
    (pcase os
      (`unix `(not (memq system-type '(ms-dos windows-nt cygwin))))
      ((or `macOS `osx) `(eq system-type 'darwin))
      (`linux `(not (memq system-type
			  '(darwin ms-dos windows-nt cygwin))))
      (`windows `(memq system-type '(ms-dos windows-nt cygwin)))))
#+end_src
** with-operating-system
If OS corresponds to the current operating system, eval and return BODY.
If not, return nil.
   
Allowable values for OS (not quoted) are `macOS', `osx',
`windows', `linux', `unix'.
#+begin_src emacs-lisp
  (defmacro radian-with-operating-system (os &rest body)
    (declare (indent 1))
    `(when (operating-system-p ,os)
       ,@body))

#+end_src
** if-compile-time
Like `if', but COND is evaluated at compile time.
The macro expands directly to either THEN or ELSE, and the other
branch is not compiled. This can be helpful to deal with code
that uses functions only defined in a specific Emacs version.
#+begin_src emacs-lisp
  (defmacro if-compile-time (cond then else)
    (declare (indent 2))
    (if (eval cond)
	then
      else))
#+end_src
** when-compile-time
Like `when', but COND is evaluated at compile time.
BODY is only compiled if COND evaluates to non-nil. This can be
helpful to deal with code that uses functions only defined in a
specific Emacs version.
#+begin_src emacs-lisp
  (defmacro radian-when-compiletime (cond &rest body)
    (declare (indent 1))
    (when (eval cond)
      `(progn ,@body)))
#+end_src
** *managed-p*
Return non-nil if FILENAME is managed by Radian.
This means that FILENAME is a symlink whose target is inside
`radian-directory'.
#+begin_src emacs-lisp
  (defun radian-managed-p (filename)
    (let ((truename (file-truename filename)))
      (string-prefix-p radian-directory truename
		       (when (if (fboundp 'file-name-case-insensitive-p)
				 (file-name-case-insensitive-p truename)
			       (with-operating-system macOS
				 t))
			 'ignore-case))))
#+end_src
** with-silent-load
Execute BODY, with the function `load' made silent.
#+begin_src emacs-lisp
  (defmacro with-silent-load (&rest body)
    (declare (indent 0))
    `(flet ((defun load (file &optional noerror _nomessage &rest args)
	      (apply load file noerror 'nomessage args)))
	   ,@body))
#+end_src
** with-silent-write
Execute BODY, with the function `write-region' made silent.
#+begin_src emacs-lisp
  (defmacro with-silent-write (&rest body)
    (declare (indent 0))
    `(flet ((defun write-region
		(start end filename &optional append visit lockname
		       mustbenew)
	      (funcall write-region start end filename append 0
		       lockname mustbenew)
	      (when (or (stringp visit) (eq visit t))
		(setq buffer-file-name
		      (if (stringp visit)
			  visit
			filename))
		(set-visited-file-modtime)
		(set-buffer-modified-p nil))))
	   (cl-letf (((symbol-function #'message) #'ignore))
	     ,@body)))
#+end_src
** with-silent-message
Silencing any messages that match REGEXPS, execute BODY.
REGEXPS is a list of strings; if `message' would display a
message string (not including the trailing newline) matching any
element of REGEXPS, nothing happens. The REGEXPS need not match
the entire message; include ^ and $ if necessary. REGEXPS may
also be a single string.
#+begin_src emacs-lisp
  (defmacro with-silent-message (regexps &rest body)
    (declare (indent 1))
    (let ((regexps-sym (cl-gensym "regexps")))
      `(let ((,regexps-sym ,regexps))
	 (when (stringp ,regexps-sym)
	   (setq ,regexps-sym (list ,regexps-sym)))
	 (radian-flet ((defun message (format &rest args)
			 (let ((str (apply #'format format args)))
#+end_src
                         ;; Can't use an unnamed block because during
                         ;; byte-compilation, some idiot loads `cl', which
                         ;; sticks an advice onto `dolist' that makes it
                         ;; behave like `cl-dolist' (i.e., wrap it in
                         ;; another unnamed block) and therefore breaks
                         ;; this code.
#+begin_src emacs-lisp
			   (cl-block done
			     (dolist (regexp ,regexps-sym)
			       (when (or (null regexp)
					 (string-match-p regexp str))
				 (cl-return-from done)))
			     (funcall message "%s" str)))))
	   ,@body))))

#+end_src
** advice-silent-message
Invoke FUNC with ARGS, silencing all messages.
This is an `:override' advice for many different functions.
#+begin_src emacs-lisp
  (defun advice-silence-messages (func &rest args)
    (cl-letf (((symbol-function #'message) #'ignore))
      (apply func args)))
#+end_src
** random-string
Return a random string designed to be globally unique.
#+begin_src emacs-lisp
  (defun random-string ()
    (md5 (format "%s%s%s%s"
		 (system-name) (emacs-pid) (current-time) (random))))
#+end_src
** list-of-strings-p
Return non-nil if OBJ is a list of strings.
#+begin_src emacs-lisp
  (defun list-of-strings-p (obj)
    (and (listp obj)
	 (cl-every #'stringp obj)))
#+end_src
** path-join
Join PATH with SEGMENTS using `expand-file-name'.
First `expand-file-name' is called on the first member of
SEGMENTS, with PATH as DEFAULT-DIRECTORY. Then `expand-file-name'
is called on the second member, with the result of the first call
as DEFAULT-DIRECTORY, and so on. If no SEGMENTS are passed, the
return value is just PATH.
#+begin_src emacs-lisp
  (defun radian--path-join (path &rest segments)
    (while segments
      (setq path (expand-file-name (pop segments) path)))
    path)
#+end_src
** *before-straight-hook*
Hook run just before Radian bootstraps straight.el.
For use with `radian-local-on-hook' in init.local.el.
#+begin_src emacs-lisp
  (defcustom before-straight-hook nil
    :group 'radian-hooks
    :type 'hook)
#+end_src
** *after-init-hook*
Hook run after at the very end of init.
For use with `radian-local-on-hook' in init.local.el.
#+begin_src emacs-lisp
  (defcustom after-init-hook nil
    :group 'radian-hooks
    :type 'hook)
#+end_src
** hook-contents
Alist mapping local init hooks to lists of forms.
This is used to embed local init hook code directly into the
init-file at the appropriate places during byte-compilation,
without breaking macro-expansion.
#+begin_src emacs-lisp
  (defvar hook-contents nil)
#+end_src
** straight-current-profile
Allow binding this variable dynamically before straight.el has been loaded.
#+begin_src emacs-lisp
  (defvar straight-current-profile)
#+end_src
** *load-local-init-file*
Load local init-file, with crazy hacks for byte-compilation.
In particular, if we are byte-compiling, actually macroexpand to
the entire contents of the local init-file, except that the
bodies of invocations to `radian-local-on-hook' are recorded in
`radian--hook-contents'. Otherwise just load the file like
usual.
#+begin_src emacs-lisp
  (defmacro radian--load-local-init-file ()
    (if byte-compile-current-file
	(let ((forms nil))
	  (with-temp-buffer
	    (ignore-errors
	      ;; Can't do this literally because it breaks Unicode
	      ;; characters.
	      (insert-file-contents radian-local-init-file))
	    (condition-case _
		(while t
		  (let ((form (read (current-buffer))))
		    (if (and (listp form)
			     (eq (nth 0 form) #'radian-local-on-hook)
			     (nth 1 form)
			     (symbolp (nth 1 form))
			     (nthcdr 2 form))
			(let* ((name (nth 1 form))
			       (body (nthcdr 2 form))
			       (hook (intern (format "%S-hook" name)))
			       (link (assq hook hook-contents)))
			  (unless link
			    (setq link (cons hook nil))
			    (push link radian--hook-contents))
			  (dolist (subform body)
			    (push subform (cdr link))))
		      (push form forms))))
	      (end-of-file)))
	  (setq forms (nreverse forms))
	  (dolist (link hook-contents)
	    (setf (cdr link)
		  (nreverse (cdr link))))
	  `(progn ,@forms))
      `(load radian-local-init-file 'noerror 'nomessage)))
#+end_src
** *local-on-hook*
Register some code to be run on one of hooks.
The hook to be used is `NAME-hook', with NAME an unquoted
symbol, and the code which is added is BODY wrapped in a `progn'.
See \\[customize-group] RET radian-hooks RET for a list of hooks
which you can use with this macro in your local init-file.
Using this macro instead of defining functions and adding them to
Hooks manually means that a lot of magic happens which
allows Radian to embed your entire local init-file into Radian
during byte-compilation without breaking macroexpansion in
unexpected ways.
#+begin_src emacs-lisp
  (defmacro local-on-hook (name &rest body)
    (declare (indent 1))
    (let ((func-name (intern (format "local--%S" name)))
	  (hook (intern (format "%S-hook" name))))
      `(progn
	 (defhook ,func-name ()
	   ,hook
	   "Automatically-generated local hook function."
	   (protect-macros
	     ,@body)))))
#+end_src
** run-hook
Run the given local init HOOK.
The hook to be used is `NAME-hook', with NAME an unquoted
symbol. This binds `straight-current-profile', and also has some
gnarly hacks to allow Radian to embed the entire contents of the
hook directly into the init-file during byte-compilation.
#+begin_src emacs-lisp
  (defmacro run-hook (name)
    (declare (indent 0))
    (let ((hook (intern (format "%S-hook" name))))
      `(let ((straight-current-profile 'radian-local))
	 (run-hooks ',hook)
	 ,@(when byte-compile-current-file
	     (alist-get hook hook-contents)))))
#+end_src
